# PR-001: ユニットテスト追加

> **Priority**: Critical
> **Effort**: High
> **Related Gap**: GAP-001

## 概要

テストコードを追加し、コア機能のテストカバレッジを70%以上に引き上げる。

## 背景

- 現状テストカバレッジ: 0%
- 目標カバレッジ: >= 70%
- リグレッションリスクが高く、リファクタリングも困難な状態

## 変更内容

### 1. テスト依存関係の追加

```kotlin
// app/build.gradle.kts に追加

dependencies {
    // Test
    testImplementation("junit:junit:4.13.2")
    testImplementation("org.mockito.kotlin:mockito-kotlin:5.2.1")
    testImplementation("org.jetbrains.kotlinx:kotlinx-coroutines-test:1.8.0")
    testImplementation("app.cash.turbine:turbine:1.0.0")
    testImplementation("io.mockk:mockk:1.13.9")
    
    // Android Test
    androidTestImplementation("androidx.test.ext:junit:1.1.5")
    androidTestImplementation("androidx.test.espresso:espresso-core:3.5.1")
    androidTestImplementation("androidx.compose.ui:ui-test-junit4")
    debugImplementation("androidx.compose.ui:ui-test-manifest")
}
```

### 2. テストファイル作成

#### 2.1 SlackMessageBuilderTest.kt

```kotlin
// app/src/test/java/jp/co/screentime/slackreporter/data/slack/SlackMessageBuilderTest.kt

package jp.co.screentime.slackreporter.data.slack

import android.content.Context
import io.mockk.every
import io.mockk.mockk
import jp.co.screentime.slackreporter.domain.model.AppUsage
import jp.co.screentime.slackreporter.platform.AppLabelResolver
import org.junit.Assert.*
import org.junit.Before
import org.junit.Test

class SlackMessageBuilderTest {
    
    private lateinit var context: Context
    private lateinit var appLabelResolver: AppLabelResolver
    private lateinit var messageBuilder: SlackMessageBuilder
    
    @Before
    fun setup() {
        context = mockk(relaxed = true)
        appLabelResolver = mockk()
        
        // Mock string resources
        every { context.getString(any()) } returns "テスト"
        every { context.getString(any(), any()) } returns "テスト"
        every { context.resources.getQuantityString(any(), any(), any()) } returns "分"
        
        messageBuilder = SlackMessageBuilder(context, appLabelResolver)
    }
    
    @Test
    fun `build returns message with header when usage list is not empty`() {
        val usageList = listOf(
            AppUsage("com.youtube", 1800000L), // 30分
            AppUsage("com.chrome", 900000L)    // 15分
        )
        every { appLabelResolver.getAppLabel("com.youtube") } returns "YouTube"
        every { appLabelResolver.getAppLabel("com.chrome") } returns "Chrome"
        
        val result = messageBuilder.build(usageList)
        
        assertNotNull(result)
        assertTrue(result.isNotEmpty())
    }
    
    @Test
    fun `build returns no usage message when list is empty`() {
        val result = messageBuilder.build(emptyList())
        
        assertNotNull(result)
    }
    
    @Test
    fun `build shows top 5 apps and aggregates others`() {
        val usageList = (1..7).map { 
            AppUsage("com.app$it", (60000 * it).toLong())
        }
        usageList.forEach { 
            every { appLabelResolver.getAppLabel(it.packageName) } returns "App${it.packageName.last()}"
        }
        
        val result = messageBuilder.build(usageList)
        
        assertNotNull(result)
    }
}
```

#### 2.2 SlackWebhookValidatorTest.kt

```kotlin
// app/src/test/java/jp/co/screentime/slackreporter/data/slack/SlackWebhookValidatorTest.kt

package jp.co.screentime.slackreporter.data.slack

import org.junit.Assert.*
import org.junit.Test

class SlackWebhookValidatorTest {
    
    @Test
    fun `validate returns success for valid Slack webhook URL`() {
        val validUrl = "https://hooks.slack.com/services/T00000000/B00000000/XXXXXXXXXXXXXXXXXXXXXXXX"
        
        val result = SlackWebhookValidator.validate(validUrl)
        
        assertTrue(result.isSuccess)
        assertEquals(validUrl, result.getOrNull())
    }
    
    @Test
    fun `validate returns failure for empty URL`() {
        val result = SlackWebhookValidator.validate("")
        
        assertTrue(result.isFailure)
    }
    
    @Test
    fun `validate returns failure for non-Slack URL`() {
        val result = SlackWebhookValidator.validate("https://example.com/webhook")
        
        assertTrue(result.isFailure)
    }
    
    @Test
    fun `validate returns failure for invalid URL format`() {
        val result = SlackWebhookValidator.validate("not-a-url")
        
        assertTrue(result.isFailure)
    }
    
    @Test
    fun `validate returns failure for HTTP URL`() {
        val result = SlackWebhookValidator.validate("http://hooks.slack.com/services/xxx")
        
        assertTrue(result.isFailure)
    }
}
```

#### 2.3 SendDailyReportUseCaseTest.kt

```kotlin
// app/src/test/java/jp/co/screentime/slackreporter/domain/usecase/SendDailyReportUseCaseTest.kt

package jp.co.screentime.slackreporter.domain.usecase

import io.mockk.*
import jp.co.screentime.slackreporter.data.repository.SettingsRepository
import jp.co.screentime.slackreporter.data.repository.SlackRepository
import jp.co.screentime.slackreporter.data.slack.SlackMessageBuilder
import jp.co.screentime.slackreporter.domain.model.AppSettings
import jp.co.screentime.slackreporter.domain.model.AppUsage
import jp.co.screentime.slackreporter.domain.model.SendStatus
import kotlinx.coroutines.flow.flowOf
import kotlinx.coroutines.test.runTest
import org.junit.Assert.*
import org.junit.Before
import org.junit.Test

class SendDailyReportUseCaseTest {
    
    private lateinit var getTodayUsageUseCase: GetTodayUsageUseCase
    private lateinit var settingsRepository: SettingsRepository
    private lateinit var slackRepository: SlackRepository
    private lateinit var slackMessageBuilder: SlackMessageBuilder
    private lateinit var useCase: SendDailyReportUseCase
    
    @Before
    fun setup() {
        getTodayUsageUseCase = mockk()
        settingsRepository = mockk()
        slackRepository = mockk()
        slackMessageBuilder = mockk()
        
        useCase = SendDailyReportUseCase(
            getTodayUsageUseCase,
            settingsRepository,
            slackRepository,
            slackMessageBuilder
        )
    }
    
    @Test
    fun `invoke returns FAILED when webhook is not configured`() = runTest {
        val settings = mockk<AppSettings> {
            every { isWebhookConfigured } returns false
        }
        every { settingsRepository.settingsFlow } returns flowOf(settings)
        
        val result = useCase()
        
        assertEquals(SendStatus.FAILED, result.status)
        assertNotNull(result.errorMessage)
    }
    
    @Test
    fun `invoke returns SUCCESS when send succeeds`() = runTest {
        val settings = mockk<AppSettings> {
            every { isWebhookConfigured } returns true
            every { webhookUrl } returns "https://hooks.slack.com/services/xxx"
            every { excludedPackages } returns emptySet()
        }
        every { settingsRepository.settingsFlow } returns flowOf(settings)
        coEvery { getTodayUsageUseCase() } returns listOf(
            AppUsage("com.test", 60000L)
        )
        every { slackMessageBuilder.build(any()) } returns "test message"
        coEvery { slackRepository.sendMessage(any(), any()) } returns Result.success(Unit)
        coEvery { settingsRepository.updateSendResult(any(), any(), any()) } just Runs
        
        val result = useCase()
        
        assertEquals(SendStatus.SUCCESS, result.status)
    }
    
    @Test
    fun `invoke filters excluded packages`() = runTest {
        val settings = mockk<AppSettings> {
            every { isWebhookConfigured } returns true
            every { webhookUrl } returns "https://hooks.slack.com/services/xxx"
            every { excludedPackages } returns setOf("com.excluded")
        }
        every { settingsRepository.settingsFlow } returns flowOf(settings)
        
        val usageList = listOf(
            AppUsage("com.included", 60000L),
            AppUsage("com.excluded", 30000L)
        )
        coEvery { getTodayUsageUseCase() } returns usageList
        
        val capturedUsage = slot<List<AppUsage>>()
        every { slackMessageBuilder.build(capture(capturedUsage)) } returns "test"
        coEvery { slackRepository.sendMessage(any(), any()) } returns Result.success(Unit)
        coEvery { settingsRepository.updateSendResult(any(), any(), any()) } just Runs
        
        useCase()
        
        assertEquals(1, capturedUsage.captured.size)
        assertEquals("com.included", capturedUsage.captured[0].packageName)
    }
}
```

### 3. テストディレクトリ構造

```
app/src/test/java/jp/co/screentime/slackreporter/
├── data/
│   ├── repository/
│   │   └── SettingsRepositoryTest.kt
│   └── slack/
│       ├── SlackMessageBuilderTest.kt
│       ├── SlackWebhookClientTest.kt
│       └── SlackWebhookValidatorTest.kt
├── domain/
│   └── usecase/
│       ├── GetTodayUsageUseCaseTest.kt
│       └── SendDailyReportUseCaseTest.kt
└── presentation/
    ├── home/
    │   └── HomeViewModelTest.kt
    └── settings/
        └── SettingsViewModelTest.kt
```

## 検証方法

```bash
# テスト実行
./gradlew test

# カバレッジレポート生成（JaCoCo設定後）
./gradlew jacocoTestReport
```

## 期待される効果

- テストカバレッジ: 0% → 70%+
- リファクタリング安全性の向上
- CI/CDでの品質ゲート有効化

## リスク

- テスト追加により既存コードの問題が発覚する可能性
- モック設定の複雑さ（Context依存クラス）

## ロールバック手順

```bash
# テストディレクトリの削除（非推奨）
rm -rf app/src/test/
rm -rf app/src/androidTest/
```

## 関連ファイル

- `app/build.gradle.kts` - 依存関係追加
- `app/src/test/` - テストコード
- `app/src/androidTest/` - UIテスト（Phase 2）
