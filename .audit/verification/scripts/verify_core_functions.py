"""
Core Function Verification Script
Generated by Repo Genesis Auditor (audit-run-001)

This script verifies the core functions of the ScreenTime Slack Reporter Android app
by analyzing the codebase structure, test coverage, and architectural compliance.

Note: This is a static analysis verification script since the target is an Android app
that requires Android SDK/emulator for runtime verification.
"""
import json
import os
import re
import sys
from dataclasses import dataclass, asdict
from pathlib import Path
from typing import Any, Optional


@dataclass
class VerificationResult:
    function_id: str
    scenario_name: str
    passed: bool
    actual_output: Any
    expected_output: Any
    error_message: Optional[str] = None
    interpretation: str = ""


# Project root (relative to .audit/)
PROJECT_ROOT = Path(__file__).resolve().parents[3]
APP_SRC = PROJECT_ROOT / "app" / "src"
MAIN_SRC = APP_SRC / "main" / "java" / "jp" / "co" / "screentime" / "slackreporter"
TEST_SRC = APP_SRC / "test" / "java" / "jp" / "co" / "screentime" / "slackreporter"


def verify_cf001_usage_stats_retrieval() -> VerificationResult:
    """CF-001: UsageStatsManagerでアプリ別利用時間を取得できる"""

    source_file = MAIN_SRC / "data" / "usage" / "UsageStatsDataSource.kt"
    test_file = TEST_SRC / "data" / "usage" / "UsageStatsDataSourceTest.kt"
    usecase_file = MAIN_SRC / "domain" / "usecase" / "GetTodayUsageUseCase.kt"
    usecase_test = TEST_SRC / "domain" / "usecase" / "GetTodayUsageUseCaseTest.kt"

    checks = {
        "source_exists": source_file.exists(),
        "test_exists": test_file.exists(),
        "usecase_exists": usecase_file.exists(),
        "usecase_test_exists": usecase_test.exists(),
    }

    if source_file.exists():
        content = source_file.read_text()
        checks["uses_usage_stats_manager"] = "UsageStatsManager" in content
        checks["queries_daily_interval"] = "INTERVAL_DAILY" in content
        checks["filters_zero_duration"] = "durationMillis > 0" in content
        checks["groups_by_package"] = "groupBy" in content
    else:
        checks["uses_usage_stats_manager"] = False

    passed = all(checks.values())

    return VerificationResult(
        function_id="CF-001",
        scenario_name="UsageStatsManager利用時間取得",
        passed=passed,
        actual_output=checks,
        expected_output="全チェック項目がTrue",
        interpretation=(
            "UsageStatsDataSourceが正しく実装され、テストも存在する"
            if passed
            else f"不合格項目: {[k for k, v in checks.items() if not v]}"
        ),
    )


def verify_cf002_slack_webhook_send() -> VerificationResult:
    """CF-002: Slack Incoming Webhookへ送信できる"""

    client_file = MAIN_SRC / "data" / "slack" / "SlackWebhookClient.kt"
    validator_file = MAIN_SRC / "data" / "slack" / "SlackWebhookValidator.kt"
    builder_file = MAIN_SRC / "data" / "slack" / "SlackMessageBuilder.kt"
    worker_file = MAIN_SRC.parent.parent.parent.parent / "workers" / "DailySlackReportWorker.kt"
    client_test = TEST_SRC / "data" / "slack" / "SlackWebhookClientTest.kt"
    validator_test = TEST_SRC / "data" / "slack" / "SlackWebhookValidatorTest.kt"
    builder_test = TEST_SRC / "data" / "slack" / "SlackMessageBuilderTest.kt"

    checks = {
        "client_exists": client_file.exists(),
        "validator_exists": validator_file.exists(),
        "builder_exists": builder_file.exists(),
        "client_test_exists": client_test.exists(),
        "validator_test_exists": validator_test.exists(),
        "builder_test_exists": builder_test.exists(),
    }

    if validator_file.exists():
        content = validator_file.read_text()
        checks["validates_https"] = 'parsedUrl.scheme != "https"' in content
        checks["validates_host"] = "hooks.slack.com" in content
        checks["validates_path"] = "/services/" in content

    if client_file.exists():
        content = client_file.read_text()
        checks["uses_okhttp"] = "OkHttpClient" in content
        checks["posts_json"] = "application/json" in content
        checks["handles_errors"] = "Result.failure" in content

    passed = all(checks.values())

    return VerificationResult(
        function_id="CF-002",
        scenario_name="Slack Webhook送信",
        passed=passed,
        actual_output=checks,
        expected_output="全チェック項目がTrue",
        interpretation=(
            "Slack Webhook送信機能が正しく実装され、URL検証・エラーハンドリング・テストが揃っている"
            if passed
            else f"不合格項目: {[k for k, v in checks.items() if not v]}"
        ),
    )


def verify_cf003_exclusion_filter() -> VerificationResult:
    """CF-003: 除外アプリのフィルタリング"""

    usecase_file = MAIN_SRC / "domain" / "usecase" / "SendDailyReportUseCase.kt"
    usecase_test = TEST_SRC / "domain" / "usecase" / "SendDailyReportUseCaseTest.kt"
    settings_file = MAIN_SRC / "domain" / "model" / "AppSettings.kt"

    checks = {
        "usecase_exists": usecase_file.exists(),
        "usecase_test_exists": usecase_test.exists(),
        "settings_model_exists": settings_file.exists(),
    }

    if usecase_file.exists():
        content = usecase_file.read_text()
        checks["filters_excluded"] = "excludedPackages" in content
        checks["applies_filter"] = "!in" in content or "filter" in content

    if settings_file.exists():
        content = settings_file.read_text()
        checks["has_excluded_packages"] = "excludedPackages" in content

    passed = all(checks.values())

    return VerificationResult(
        function_id="CF-003",
        scenario_name="除外アプリフィルタリング",
        passed=passed,
        actual_output=checks,
        expected_output="全チェック項目がTrue",
        interpretation=(
            "除外アプリ機能が正しく実装され、SendDailyReportUseCaseでフィルタが適用されている"
            if passed
            else f"不合格項目: {[k for k, v in checks.items() if not v]}"
        ),
    )


def verify_cf004_manual_send() -> VerificationResult:
    """CF-004: 手動送信"""

    home_vm_file = MAIN_SRC / "presentation" / "home" / "HomeViewModel.kt"
    home_vm_test = TEST_SRC / "presentation" / "home" / "HomeViewModelTest.kt"

    checks = {
        "viewmodel_exists": home_vm_file.exists(),
        "viewmodel_test_exists": home_vm_test.exists(),
    }

    if home_vm_file.exists():
        content = home_vm_file.read_text()
        checks["has_send_function"] = (
            "sendDailyReport" in content.lower()
            or "send" in content.lower()
        )
        checks["calls_usecase"] = "SendDailyReportUseCase" in content

    passed = all(checks.values())

    return VerificationResult(
        function_id="CF-004",
        scenario_name="手動送信",
        passed=passed,
        actual_output=checks,
        expected_output="全チェック項目がTrue",
        interpretation=(
            "HomeViewModelから手動送信が可能で、SendDailyReportUseCaseを呼び出している"
            if passed
            else f"不合格項目: {[k for k, v in checks.items() if not v]}"
        ),
    )


def verify_cf005_webhook_validation() -> VerificationResult:
    """CF-005: Webhook URLバリデーション"""

    validator_file = MAIN_SRC / "data" / "slack" / "SlackWebhookValidator.kt"
    validator_test = TEST_SRC / "data" / "slack" / "SlackWebhookValidatorTest.kt"

    checks = {
        "validator_exists": validator_file.exists(),
        "validator_test_exists": validator_test.exists(),
    }

    if validator_file.exists():
        content = validator_file.read_text()
        checks["checks_https"] = 'parsedUrl.scheme != "https"' in content
        checks["checks_host"] = "hooks.slack.com" in content or "WEBHOOK_HOST" in content
        checks["checks_path_prefix"] = "/services/" in content or "WEBHOOK_PATH_PREFIX" in content

    passed = all(checks.values())

    return VerificationResult(
        function_id="CF-005",
        scenario_name="Webhook URLバリデーション",
        passed=passed,
        actual_output=checks,
        expected_output="全チェック項目がTrue",
        interpretation=(
            "Webhook URLバリデーションが正しく実装されている（HTTPS, ホスト, パスプレフィックス検証確認済み）"
            if passed
            else f"不合格項目: {[k for k, v in checks.items() if not v]}"
        ),
    )


def verify_architecture_compliance() -> VerificationResult:
    """ARCH-001: Clean Architecture準拠の検証"""

    base = MAIN_SRC

    checks = {
        "domain_layer_exists": (base / "domain").is_dir(),
        "data_layer_exists": (base / "data").is_dir(),
        "presentation_layer_exists": (base / "presentation").is_dir(),
        "ui_layer_exists": (base / "ui").is_dir(),
        "di_layer_exists": (base / "di").is_dir(),
        "workers_layer_exists": (base / "workers").is_dir() or (base.parent.parent.parent.parent / "workers").is_dir(),
        "domain_has_no_android_imports": True,
    }

    # domain層がAndroid SDKに依存していないことを確認
    domain_dir = base / "domain"
    if domain_dir.is_dir():
        for kt_file in domain_dir.rglob("*.kt"):
            content = kt_file.read_text()
            if "import android." in content:
                checks["domain_has_no_android_imports"] = False
                break

    passed = all(checks.values())

    return VerificationResult(
        function_id="ARCH-001",
        scenario_name="Clean Architectureアーキテクチャ準拠",
        passed=passed,
        actual_output=checks,
        expected_output="全チェック項目がTrue",
        interpretation=(
            "Clean Architectureに準拠（全レイヤー存在、domain層はAndroid SDK非依存）"
            if passed
            else f"アーキテクチャ違反: {[k for k, v in checks.items() if not v]}"
        ),
    )


def verify_test_coverage_setup() -> VerificationResult:
    """QA-001: テストカバレッジ設定の検証"""

    build_file = PROJECT_ROOT / "app" / "build.gradle.kts"
    test_dir = APP_SRC / "test"

    checks = {
        "build_file_exists": build_file.exists(),
        "jacoco_plugin": False,
        "jacoco_report_task": False,
        "test_dir_exists": test_dir.is_dir(),
        "test_files_count_sufficient": False,
    }

    if build_file.exists():
        content = build_file.read_text()
        checks["jacoco_plugin"] = "jacoco" in content
        checks["jacoco_report_task"] = "jacocoTestReport" in content

    if test_dir.is_dir():
        test_files = list(test_dir.rglob("*Test.kt"))
        checks["test_files_count_sufficient"] = len(test_files) >= 10

    passed = all(checks.values())

    return VerificationResult(
        function_id="QA-001",
        scenario_name="テストカバレッジ設定",
        passed=passed,
        actual_output=checks,
        expected_output="全チェック項目がTrue",
        interpretation=(
            "JaCoCo設定済み、十分なテストファイルが存在（実測カバレッジはビルド実行が必要）"
            if passed
            else f"テスト設定不足: {[k for k, v in checks.items() if not v]}"
        ),
    )


def verify_security() -> VerificationResult:
    """SEC-001: セキュリティ検証"""

    checks = {
        "no_hardcoded_webhook": True,
        "webhook_validator_exists": False,
        "gitignore_local_properties": False,
        "gitignore_keystore": False,
    }

    # ソースコード内にWebhook URLがハードコードされていないことを確認
    src_dir = APP_SRC / "main"
    webhook_pattern = re.compile(r"https://hooks\.slack\.com/services/T[A-Z0-9]+/B[A-Z0-9]+/")
    if src_dir.is_dir():
        for kt_file in src_dir.rglob("*.kt"):
            content = kt_file.read_text()
            if webhook_pattern.search(content):
                checks["no_hardcoded_webhook"] = False
                break

    validator_file = MAIN_SRC / "data" / "slack" / "SlackWebhookValidator.kt"
    checks["webhook_validator_exists"] = validator_file.exists()

    gitignore = PROJECT_ROOT / ".gitignore"
    if gitignore.exists():
        content = gitignore.read_text()
        checks["gitignore_local_properties"] = "local.properties" in content
        checks["gitignore_keystore"] = "*.keystore" in content or "*.jks" in content

    passed = all(checks.values())

    return VerificationResult(
        function_id="SEC-001",
        scenario_name="セキュリティ検証",
        passed=passed,
        actual_output=checks,
        expected_output="全チェック項目がTrue",
        interpretation=(
            "セキュリティ要件を満たしている（Webhook URLハードコードなし、バリデーション実装済み、秘匿ファイルgitignore済み）"
            if passed
            else f"セキュリティ問題: {[k for k, v in checks.items() if not v]}"
        ),
    )


def main():
    """全Core Functionを検証し、レポートを生成"""

    results = [
        verify_cf001_usage_stats_retrieval(),
        verify_cf002_slack_webhook_send(),
        verify_cf003_exclusion_filter(),
        verify_cf004_manual_send(),
        verify_cf005_webhook_validation(),
        verify_architecture_compliance(),
        verify_test_coverage_setup(),
        verify_security(),
    ]

    print("=" * 60)
    print("CORE FUNCTION VERIFICATION REPORT")
    print(f"Repository: screen-time-slack-reporter-android")
    print(f"Run ID: audit-run-001")
    print("=" * 60)

    passed_count = sum(1 for r in results if r.passed)
    total_count = len(results)

    for r in results:
        status = "PASS" if r.passed else "FAIL"
        print(f"\n{status} [{r.function_id}] {r.scenario_name}")
        print(f"  Interpretation: {r.interpretation}")
        if r.error_message:
            print(f"  Error: {r.error_message}")

    print("\n" + "=" * 60)
    print(f"SUMMARY: {passed_count}/{total_count} passed")

    if passed_count == total_count:
        print("Verdict: Repository's core functions are verified")
    else:
        print("Verdict: Some core functions need attention")
        print("\nNext actions:")
        for r in results:
            if not r.passed:
                print(f"  - {r.function_id}: {r.interpretation}")

    # 結果をJSONで保存
    output_path = PROJECT_ROOT / ".audit" / "output" / "verification_result.json"
    output_path.parent.mkdir(parents=True, exist_ok=True)
    output_path.write_text(
        json.dumps([asdict(r) for r in results], ensure_ascii=False, indent=2)
    )
    print(f"\nResults saved to: {output_path}")

    sys.exit(0 if passed_count == total_count else 1)


if __name__ == "__main__":
    main()
